# Using dplyr with databases

Chapter 2 of @tanimura2021sql provides a good foundation discussion of issues related to preparing data for analysis.
While the discussion is couched in terms of SQL, in reality the issues are not specific to SQL or databases.
For this reason, I recommend that you read the chapter.

In this chapter, I instead show how `dplyr`, a core Tidyverse package, can be used with SQL databases.

## Introduction to dplyr

Our focus on using R and `dplyr` to access SQL databases means that we only need to learn a subset of the functionality of R.

While R offers a number of data structures---including vectors, lists, and matrices---we will focus primarily on data frames, which are R's equivalents of tables in SQL databases.
R also offers rich functionality for statistical testing and modelling, but we will make little use of this here.

```{r}
#| message: false
#| eval: true
#| cache: false
library(DBI)
library(tidyverse)

retail_sales_local <- read_csv("data/us_retail_sales.csv",
                               show_col_types = FALSE)

db <- dbConnect(duckdb::duckdb())
retail_sales <- 
  retail_sales_local |>
  copy_to(db, df = _, name = "retail_sales")
```

### Introduction to SQL

```{r}
retail_sales <- tbl(db, "retail_sales")
```

```{r}
retail_sales
```

```{sql}
#| eval: false
#| connection: db
SELECT sales_month, kind_of_business, sales
FROM retail_sales
```

```{r}
retail_sales |>
  select(sales_month, kind_of_business, sales)
```

```{sql}
#| connection: db
#| eval: false
SELECT sales_month, kind_of_business, sales
FROM retail_sales
WHERE sales_month >= '2002-01-01'
```

```{r}
retail_sales |>
  select(sales_month, kind_of_business, sales) |>
  filter(sales_month >= '2002-01-01')
```


```{sql}
#| connection: db
#| eval: false
SELECT sales_month, kind_of_business, sales
FROM retail_sales
WHERE 
```

 - Use `==` instead of `=`.
 - Can use `"` or `'` for quotes.

```{r}
retail_sales |>
  select(sales_month, kind_of_business, sales) |>
  filter(kind_of_business == 'Used car dealers')
```

```{sql}
#| connection: db
SELECT kind_of_business, sum(sales) AS total_sales
FROM retail_sales
GROUP BY kind_of_business
ORDER BY total_sales DESC;
```
 - use `na.rm = TRUE`
 - Put new variable name to the left of aggregate function
 - Use `arrange()` instead of `ORDER BY`
 - Use `desc()` instead of `DESC`
 - No need to separately select `GROUP BY` variables.
 - No exact equivalent to reference by order
 
```{r}
retail_sales |>
  group_by(kind_of_business) |>
  summarize(total_sales = sum(sales, na.rm = TRUE)) |>
  arrange(desc(total_sales))
```

```{r}
retail_sales |>
  group_by(kind_of_business) |>
  summarize(total_sales = sum(sales, na.rm = TRUE)) |>
  arrange(desc(total_sales))
```


```{sql}
#| connection: db
SELECT year(sales_month) AS year,
  sum(sales) AS total_sales
FROM retail_sales
WHERE kind_of_business = 'Used car dealers'
GROUP BY 1
ORDER BY 2 DESC;
```

```{r}
retail_sales |>
  mutate(year = year(sales_month)) |>
  filter(kind_of_business == 'Used car dealers') |>
  group_by(year) |>
  summarize(total_sales = sum(sales, na.rm = TRUE)) |>
  arrange(desc(total_sales))
```


```{sql}
#| connection: db
SELECT year(sales_month) AS year,
  sum(sales) AS total_sales
FROM retail_sales
WHERE kind_of_business = 'Used car dealers'
GROUP BY 1
HAVING total_sales >= 100000
ORDER BY 2 DESC;
```

```{r}
retail_sales |>
  mutate(year = year(sales_month)) |>
  filter(kind_of_business == 'Used car dealers') |>
  group_by(year) |>
  summarize(total_sales = sum(sales, na.rm = TRUE)) |>
  filter(total_sales >= 100000) |>
  arrange(desc(total_sales)) 
```

```{sql}
#| connection: db
SELECT kind_of_business, reason_for_null,
  count(*) AS num_null
FROM retail_sales
WHERE sales IS NULL
GROUP BY 1, 2
ORDER BY 3 DESC
```
 - `is.na()` instead of `IS NULL`
 
```{r}
retail_sales |>
  filter(is.na(sales)) |>
  group_by(kind_of_business, reason_for_null) |>
  summarize(num_null = n(), .groups = "drop") %>%
  arrange(desc(num_null))
```

### Missing data

The SQL in the book generally uses the form `x::date` rather than the more standard SQL `CAST(x AS DATE)`.
In `dbplyr`, we would use `as.Date(x)` and `dbplyr` would translate as `CAST(x AS DATE)`.
The following code and output demonstrates how `dbplyr` translated from `dplyr` to SQL.

The table stored in `dates_processed` below is equivalent to that created and stored in the database as `date_dim` in the code supplied with book.
This `date_dim` table is only used in #sec-time-series of the book and we will not even use it there (for reasons to be explained).

```{r}
#| message: false
library(tidyverse)
library(DBI)
library(knitr)
```

```{r}
#| output: false
pg <- dbConnect(RPostgres::Postgres(), 
                bigint = "integer",
                check_interrupts = TRUE)
```

```{r}
#| include: false
dbExecute(pg, "SET search_path TO sql_book")
```

## Preparing: Shaping Data

### For Which Output: BI, Visualization, Statistics, ML

### Pivoting with CASE Statements

### Unpivoting with UNION Statements

A user of `dplyr` has access to the functions `pivot_wider` and `pivot_longer`, which make it much easier to "pivot" and "unpivot" tables than using `CASE` statements, which could become long and tedious.

To illustrate the `dplyr` way of doing things, I will create `ctry_pops` to match the data discussed in Chapter 2.
First, I create the data set using the `tribble()` function from `dplyr`.

```{r}
ctry_pops <-
  tribble(
  ~country, ~year_1980,  ~year_1990, ~year_2000, ~year_2010,
  "Canada", 24593, 27791, 31100, 34207,
  "Mexico", 68347, 84634, 99775, 114061,
  "United States", 227225, 249623, 282162, 309326
)
```

Second, I pivot the local data frame using `pivot_longer`.

```{r}
ctry_pops_long <-
  ctry_pops |>
  pivot_longer(cols = -country, 
               names_to = "year",
               names_prefix = "year_",
               values_ptypes = integer(),
               values_to = "population") 
ctry_pops_long |>
  kable()
```

Next, I copy the data to PostgreSQL, so that it's a (temporary) table inside the database.^["Temporary" here means that it will disappear once we close our connection to the database.]

```{r}
ctry_pops_db <- copy_to(pg, ctry_pops)
ctry_pops_db
```

```{r}
ctry_pops_db_long <-
  ctry_pops_db |>
  pivot_longer(cols = -country, 
               names_to = "year",
               names_prefix = "year_",
               values_to = "population") 
```

From the output below, we can see that `dbplyr` has taken care of the tedious business of constructing several statements for us.

```{r}
ctry_pops_db_long |>
  show_query()
```

And from the following, we can see that the result is the same as it was when using `dplyr` on a local data frame.

```{r}
ctry_pops_db_long |>
  kable()
```

And we can reverse the `pivot_longer()` using `pivot_wider()`.

```{r}
ctry_pops_db_long |>
  compute() |>
  pivot_wider(names_from = year, 
              values_from = population, 
              names_prefix = "year_") |>
  kable()
```

### pivot and unpivot Functions

