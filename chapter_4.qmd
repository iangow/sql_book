# Cohorts

## Cohorts: A Useful Analysis Framework

Chapter 4 examines the fascinating topic of cohorts, where a cohort is a group of observations (often people) who acquire a shared characteristic at (approximately) the same time.
For example, children entering kindergarten in New Zealand in 2017 or the Harvard MBA Class of 2002.

While cohort analysis has some attractive features, I guess that data do not often come in a format that facilitates such analysis.
Instead, as is the case with the *legislators* data set studied in Chapter 4, the data analyst needs to rearrange the data to support cohort analysis.

I found Chapter 4 a little confusing on a first pass through it.^[In writing this sentence, I am still working through the chapter.]
The chapter launches into some SQL code intended to create cohorts, but it's a little unclear why we're doing what we're doing, and we quickly see that our cohort analysis does not make sense (e.g., we have more of our original cohort in period 5 than we had in period 4) and we must have done something wrong.
I think I see the idea Cathy is going for here: one needs to think carefully about how to arrange the data to avoid subtle mistakes.
The challenge I see is that it's not obvious that everyone would make the same mistake and one is too deep in the weeds of the code to really see the forest for the trees.

So before I launch into the code, I will spend a little time thinking about things conceptually.
I will start with a different example from that used in Chapter 4, but one that I think brings out some of the issues.

For some reason I associate cohort analysis with life expectancy.
The people who are born today form a cohort and one might ask: How long do we expect members of this cohort to live?
One often hears life expectancy statistics quoted as something like: "In Australia, a boy born in 2018–2020 can expect to live to the age of 81.2 years and a girl would be expected to live to 85.3 years compared to 51.1 for boys and 54.8 years for girls born in in 1891–1900."^[See [here](https://www.aihw.gov.au/reports/life-expectancy-death/deaths-in-australia/contents/life-expectancy) for the source for these data.]

The people who construct the life expectancies for the children must be veritable polymaths.
They need to anticipate future developments in medical care and technology.
Skin cancer is a significant cause of death in Australia, due to a mismatch between the median complexion and the intensity of the sun.
But the analysts calculating life expectancy need to think about how medical technology is likely to affect rates of death from carcinoma in the future.
I can imagine whole-body scanners a bit like the scanners in US airports that detect skin cancers before they become problematic.
These analysts also need to understand how road safety will evolve.
Will children today all be in driverless vehicles in fifty years time and will accidents then be a rarity?
And what about war?
The data analyst needs to be able to forecast the possibility of World War III breaking out and shortening life spans.
Who are these people?

Of course it seems unlikely these *über*-analysts exist.
Rather they surely do something more prosaic.
Here is my *guess* as to how life expectancies are constructed.^[I made no effort to research how they are constructed because (1) I am lazy and (2) my imagined version is probably better for my current purposes.]
I guess that the data analyst gathers data on cohorts notionally formed at some point in the past and then looks at survival rates for that cohort over some period, then aggregates those data into a life expectancy.

For example, the data analyst might gather data on people who turned 21 in 2018 and then data on whether those people surived to their 22nd birthday.
The proportion of such people who make their 22nd birthday could be interpreted as a survival probability $p_{21}$.
Repeat that for each age-based cohort to get probabilities $\left\{p_i: i = 0, 1, \dots, 119, 120 \right\}$.
Now to find the median life expectancy, we could calculate something like this:^[There are some details I'm glossing over here, such as the fact that there will be some $j$ where the cumulative survival probability is just above one-half, but where that for $j + 1$ is just below one-half, so some interpolation will be required.]

$$ \left\{j: \arg \min_{i} \left(\prod_{0}^{i} p_i\right) \leq \frac{1}{2} \right\} $$
So we have a (fairly) well-defined procedure here.
There are obviously some details to be worked out.
For example, do we focus on one year (2018 in this case)? Or collect data over multiple years?
Does it make sense to form cohorts by years?
Or would grouping into larger cohorts (e.g., 20--25) make more sense?
Do we identify people by birthdays?
Or just use some kind of census date?
(People who are 21 on 1 July might have just turned 21, or might be about to turn 22.)

But what exactly have we calculated?
In a sense it's a nonsensical number.
Why would survival rates for 88-year-olds in 2018 be relevant for the life expectancy of newborns today, who will face a very different world when they turn 88 in 2111.
First, perhaps the analysts really don't calculate it in this way (though I'm doubtful they are polymaths).
Second, even though it's a "meaningless" number, it probably still has attractive properties, such as the ability to represent in a one or two numbers a lot about the quality of life in Australia.

A final note is that it is not clear to me where the "51.1 for boys and 54.8 years for girls born in in 1891--1900" values come from.
Are these the equivalent life expectancies calculated using data available around 1900?
Or are these the observed lifespans of people born in 1891--1900?
If the latter, how accurate were the former as estimates of these values?

## The Legislators Data Set

Now that we understand cohorts, let's move onto the *legislators* data set.

```{r}
#| warning: false
library(DBI)
library(tidyverse)
library(dbplyr)
library(ggplot2)
library(knitr)
library(duckdb)
```

If you have the tables `legislators` and `legislators_terms` in a PostgreSQL database, then you could connect to that database.

```{r}
#| output: false
#| include: true
#| eval: false
db <- dbConnect(RPostgres::Postgres(), 
                bigint = "integer",
                check_interrupts = TRUE)
```

```{r}
#| include: false
#| eval: false
dbExecute(db, "SET search_path TO sql_book")
```

Otherwise, the easiest way to get the *legislators* data set is to get the data from the GitHub site provided with @tanimura2021sql.

```{r}
#| warning: false
#| cache: true
url <- paste0("https://raw.githubusercontent.com/cathytanimura/",
              "sql_book/master/Chapter%204%3A%20Cohorts/")
legislators_df <- read_csv(paste0(url, "legislators.csv"),
                           show_col_types = FALSE)
legislators_terms_df <- read_csv(paste0(url, "legislators_terms.csv"),
                                 show_col_types = FALSE)
```

```{r}
db <- dbConnect(duckdb())
legislators <- 
  copy_to(db, legislators_df, name = "legislators")
legislators_terms <- 
  copy_to(db, legislators_terms_df, name = "legislators_terms")
```

## Retention

### SQL for a Basic Retention Curve

```{sql}
#| connection: db
SELECT id_bioguide, min(term_start) AS first_term
FROM legislators_terms 
GROUP BY 1
LIMIT 3;
```

```{sql}
#| connection: db
WITH first_terms AS (
  SELECT id_bioguide, min(term_start) AS first_term
  FROM legislators_terms 
  GROUP BY 1) 

SELECT date_part('year', age(b.term_start, a.first_term)) AS period,
  COUNT(DISTINCT a.id_bioguide) AS cohort_retained
FROM first_terms a
INNER JOIN legislators_terms b
USING (id_bioguide)
GROUP BY 1
ORDER BY 1
LIMIT 4;
```

```{r}
first_terms <- 
  legislators_terms %>%
  group_by(id_bioguide) %>%
  summarize(first_term = min(term_start, na.rm = TRUE),
            .groups = "drop")

cohorts <-
  legislators_terms %>%
  inner_join(first_terms, by = "id_bioguide") %>%
  mutate(period = year(age(term_start, first_term))) %>%
  group_by(period) %>%
  summarize(cohort_retained = sql("count(distinct id_bioguide)")) 

cohorts %>%
  arrange(period) %>%
  collect(n = 3) %>%
  kable()
```

```{sql}
#| connection: db
WITH 
first_terms AS (
  SELECT id_bioguide, min(term_start) AS first_term
  FROM legislators_terms 
  GROUP BY 1),

cohorts AS (
  SELECT date_part('year', age(b.term_start, a.first_term)) AS period,
    COUNT(DISTINCT a.id_bioguide) AS cohort_retained
  FROM first_terms a
  JOIN legislators_terms b 
  USING (id_bioguide)
  GROUP BY 1)
  
SELECT period,
  first_value(cohort_retained) OVER w AS cohort_size,
  cohort_retained,
  cohort_retained * 1.0 / 
    first_value(cohort_retained) OVER w AS prop_retained
FROM cohorts
WINDOW w AS (ORDER BY period)
LIMIT 3;
```

```{r}
retained_data <-
  cohorts %>%
  window_order(period) %>%
  mutate(cohort_size = first(cohort_retained)) %>%
  mutate(pct_retained = cohort_retained * 1.0/cohort_size) %>%
  select(period, cohort_size, cohort_retained, pct_retained) 

retained_data %>%
  collect(n = 3) %>%
  kable()
```

```{r}
retained_data %>%
  ggplot(aes(x = period, y = pct_retained)) +
  geom_line()
```

```{sql}
#| connection: db
WITH 
first_terms AS (
  SELECT id_bioguide, min(term_start) AS first_term
  FROM legislators_terms 
  GROUP BY 1),

cohorts AS (
  SELECT date_part('year', age(b.term_start, a.first_term)) AS period,
      COUNT(DISTINCT a.id_bioguide) AS cohort_retained
  FROM first_terms a
  JOIN legislators_terms b on a.id_bioguide = b.id_bioguide 
  GROUP BY 1),
  
retained_data AS (
  SELECT period,
    first_value(cohort_retained) OVER w AS cohort_size,
    cohort_retained,
    cohort_retained * 1.0 / first_value(cohort_retained) OVER w AS pct_retained
  FROM cohorts
  WINDOW w AS (ORDER BY period))

SELECT cohort_size,
  max(CASE WHEN period = 0 THEN pct_retained END) AS yr0,
  max(CASE WHEN period = 1 THEN pct_retained END) AS yr1,
  max(CASE WHEN period = 2 THEN pct_retained END) AS yr2,
  max(CASE WHEN period = 3 THEN pct_retained END) AS yr3,
  max(CASE WHEN period = 4 THEN pct_retained END) AS yr4
FROM retained_data
GROUP BY 1;
```

```{r}
retained_data %>%
  select(period, pct_retained) %>%
  filter(period <= 4) %>%
  collect() %>%
  arrange(period) %>%
  pivot_wider(names_from = period, 
              names_prefix = "yr",
              values_from = pct_retained) %>%
  collect() %>%
  kable()
```

### Adjusting Time Series to Increase Retention Accuracy

Use `copy_inline()` here if using a read-only database.

```{r}
year_ends <-
  tibble(date = seq(as.Date('1770-12-31'), 
                    as.Date('2030-12-31'), 
                    by = "1 year")) %>%
  copy_to(db, ., overwrite = TRUE, name = "year_ends")
```

```{sql}
#| connection: db
WITH

first_terms AS (
  SELECT id_bioguide, min(term_start) AS first_term
  FROM legislators_terms 
  GROUP BY 1)
  
SELECT a.id_bioguide, a.first_term, b.term_start, b.term_end,
  c.date,
  date_part('year', age(c.date, a.first_term)) AS period
FROM first_terms a
JOIN legislators_terms b USING (id_bioguide)
LEFT JOIN year_ends c
ON c.date BETWEEN b.term_start and b.term_end
ORDER BY id_bioguide
LIMIT 3;
```

```{r}
cohorts <-
  first_terms %>%
  inner_join(legislators_terms, by = join_by(id_bioguide)) %>%
  left_join(year_ends, 
            by = join_by(between(y$date, x$term_start, x$term_end))) %>%
  mutate(period = date_part('year', age(date, first_term))) %>%
  select(id_bioguide, first_term, term_start, term_end, date, period) 

cohorts %>%
  collect(n = 3) %>%
  kable()
```

```{sql}
#| connection: db
WITH

first_terms AS (
  SELECT id_bioguide, min(term_start) AS first_term
  FROM legislators_terms 
  GROUP BY 1),

cohorts_retained AS (        
    SELECT coalesce(date_part('year', age(c.date, a.first_term)), 0) AS period,
      COUNT(DISTINCT a.id_bioguide) AS cohort_retained
    FROM first_terms a
    JOIN legislators_terms b
    USING (id_bioguide)
    LEFT JOIN year_ends c ON c.date BETWEEN b.term_start AND b.term_end
    GROUP BY 1)
    
SELECT period,
  first_value(cohort_retained) OVER w AS cohort_size,
  cohort_retained,
  cohort_retained * 1.0/first_value(cohort_retained) OVER w AS pct_retained
FROM cohorts_retained
WINDOW w AS (ORDER BY period);
```

```{r}
cohorts_retained <-
  cohorts %>%
  mutate(period = coalesce(date_part('year', age(date, first_term)), 0)) %>%
  select(period, id_bioguide) %>%
  distinct() %>%
  group_by(period) %>%
  summarize(cohort_retained = n()) 

pct_retained <-
  cohorts_retained %>%
  window_order(period) %>%
  mutate(cohort_size = first(cohort_retained),
         cohort_retained = as.double(cohort_retained),
         pct_retained = cohort_retained/cohort_size) 

pct_retained %>%
  arrange(period) %>%
  collect(n = 3) %>%
  kable()
```

```{r}
pct_retained %>%
  ggplot(aes(x = period, y = pct_retained)) + 
  geom_line()
```

```{sql}
#| connection: db
WITH first_terms AS (
  SELECT id_bioguide, min(term_start) AS first_term
  FROM legislators_terms 
  GROUP BY 1)
  
SELECT id_bioguide, a.first_term, b.term_start,
  CASE WHEN b.term_type = 'rep' THEN b.term_start + interval '2 years'
       WHEN b.term_type = 'sen' THEN b.term_start + interval '6 years'
  END AS term_end
FROM first_terms a
JOIN legislators_terms b USING (id_bioguide)
LIMIT 3;
```

```{r}
first_terms %>%
  inner_join(legislators_terms, by = join_by(id_bioguide)) %>%
  mutate(term_end = 
           case_when(term_type == 'rep' ~ term_start + years(2),
                     term_type == 'sen' ~ term_start + years(6))) %>%
  select(id_bioguide, first_term, term_start, term_end)  %>%
  collect(n = 3) %>%
  kable()
```

For now, I have omitted the query after the paragraph starting "A second option ...".

### Cohorts Derived from the Time Series Itself

```{sql}
#| connection: db
WITH first_terms AS (
  SELECT id_bioguide, min(term_start) AS first_term
  FROM legislators_terms 
  GROUP BY 1)
  
SELECT date_part('year', a.first_term) AS first_year,
  COALESCE(date_part('year', age(c.date, a.first_term)), 0) AS period,
  COUNT(DISTINCT a.id_bioguide) AS cohort_retained
FROM first_terms a
INNER JOIN legislators_terms b 
USING (id_bioguide)
LEFT JOIN year_ends c 
ON c.date BETWEEN b.term_start AND b.term_end 
GROUP BY 1, 2
ORDER BY 1, 2
LIMIT 3;
```

```{r}
yr_cohort_retaineds <-
  first_terms %>%
  inner_join(legislators_terms, by = "id_bioguide") %>%
  left_join(year_ends, 
            join_by(between(y$date, x$term_start, x$term_end))) %>%
  mutate(first_year = year(first_term),
         period = coalesce(year(age(date, first_term)), 0)) %>%
  group_by(first_year, period) %>%
  summarize(cohort_retained = n_distinct(id_bioguide),
            .groups = "drop") 

yr_cohort_retaineds %>%
  arrange(first_year, period) %>%
  collect(n = 3) %>%
  kable()
```

```{r}
yr_cohort_retaineds %>%
  group_by(first_year) %>%
  window_order(period) %>%
  mutate(cohort_size = first(cohort_retained),
         pct_retained = 1.0 * cohort_retained/cohort_size) %>%
  select(first_year, period, cohort_size, cohort_retained, pct_retained) %>%
  arrange(first_year, period) %>%
  collect(n = 3) %>%
  kable()
```

```{sql}
#| connection: db
WITH first_terms AS (
  SELECT id_bioguide, min(term_start) AS first_term
  FROM legislators_terms 
  GROUP BY 1),
                
first_centuries AS (
  SELECT 
    date_part('century', a.first_term) AS first_century,
    coalesce(date_part('year', age(c.date, a.first_term)), 0) AS period,
    COUNT(DISTINCT a.id_bioguide) AS cohort_retained
  FROM first_terms AS a
  INNER JOIN legislators_terms b 
  USING (id_bioguide)
  LEFT JOIN year_ends c 
  ON c.date BETWEEN b.term_start AND b.term_end 
  GROUP BY 1, 2)

SELECT first_century, period,
  first_value(cohort_retained) OVER w AS cohort_size,
  cohort_retained,
  cohort_retained * 1.0 / first_value(cohort_retained) OVER w AS prop_retained
FROM first_centuries
WINDOW w AS (PARTITION BY first_century ORDER BY period)
ORDER BY 1, 2
LIMIT 3;
```

```{r}
cen_cohort_retaineds <-
  first_terms %>%
  inner_join(legislators_terms, by = "id_bioguide") %>%
  left_join(year_ends, 
            join_by(between(y$date, x$term_start, x$term_end))) %>%
  mutate(first_century = century(first_term),
         period = coalesce(year(age(date, first_term)), 0)) %>%
  group_by(first_century, period) %>%
  summarize(cohort_retained = n_distinct(id_bioguide),
            .groups = "drop")
```

```{r}
cen_pct_retaineds <-
  cen_cohort_retaineds %>%
  group_by(first_century) %>%
  window_order(period) %>%
  mutate(cohort_size = first(cohort_retained),
         pct_retained = 1.0 * cohort_retained/cohort_size) %>%
  ungroup() %>%
  select(first_century, period, cohort_size, cohort_retained, pct_retained) 

cen_pct_retaineds %>%
  arrange(first_century, period) %>%
  collect(n = 3) %>%
  kable()
```

```{r}
cen_pct_retaineds %>%
  collect() %>%
  mutate(first_century = factor(first_century)) %>%
  ggplot(aes(x = period, y = pct_retained,
             color = first_century,
             linetype = first_century,
             group = first_century)) + 
  geom_line()
```

```{sql}
#| connection: db
SELECT DISTINCT id_bioguide,
  min(term_start) OVER w AS first_term,
  first_value(state) OVER w AS first_state
FROM legislators_terms 
WINDOW w AS (PARTITION BY id_bioguide ORDER BY term_start)
ORDER BY id_bioguide
```
```{r}
first_states <-
  first_terms <- 
  legislators_terms %>%
  group_by(id_bioguide) %>%
  window_order(term_start) %>%
  mutate(first_term = min(term_start, na.rm = TRUE),
         first_state = first(state)) %>%
  ungroup() %>%
  select(id_bioguide, first_term, first_state) %>%
  distinct()
```


```{sql}
#| connection: db
WITH first_states AS (
  SELECT DISTINCT id_bioguide,
    min(term_start) OVER w AS first_term,
    first_value(state) OVER w AS first_state
  FROM legislators_terms 
  WINDOW w AS (PARTITION BY id_bioguide ORDER BY term_start)),

state_first_periods AS (
  SELECT 
    first_state,
    coalesce(date_part('year', age(c.date, a.first_term)), 0) AS period,
    COUNT(DISTINCT a.id_bioguide) AS cohort_retained
  FROM first_states AS a
  INNER JOIN legislators_terms b 
  USING (id_bioguide)
  LEFT JOIN year_ends c 
  ON c.date BETWEEN b.term_start AND b.term_end 
  GROUP BY 1, 2)

SELECT first_state, period,
  first_value(cohort_retained) OVER w AS cohort_size,
  cohort_retained,
  cohort_retained * 1.0 / first_value(cohort_retained) OVER w AS prop_retained
FROM state_first_periods
WINDOW w AS (PARTITION BY first_state ORDER BY period)
ORDER BY 1, 2
LIMIT 3;
```

```{r}
state_first_periods <-
  first_states %>%
  inner_join(legislators_terms, by = "id_bioguide") %>%
  left_join(year_ends, 
            join_by(between(y$date, x$term_start, x$term_end))) %>%
  mutate(period = coalesce(year(age(date, first_term)), 0)) %>%
  group_by(first_state, period) %>%
  summarize(cohort_retained = n_distinct(id_bioguide),
            .groups = "drop")
```

```{r}
state_pct_retaineds <- 
  state_first_periods %>%
  select(first_state, period, cohort_retained) %>%
  group_by(first_state) %>%
  window_order(period) %>%
  mutate(cohort_size = first(cohort_retained),
         prop_retained = cohort_retained * 1.0 / cohort_size) %>%
  ungroup()

state_pct_retaineds %>%
  arrange(first_state, period) %>%
  collect(n = 3) %>%
  kable()
```

```{r}
top_5_states <- c("NY", "PA", "OH", "IL", "MA")

state_pct_retaineds %>%
  filter(first_state %in% top_5_states) %>%
  ggplot(aes(x = period, 
             y = prop_retained,
             color = first_state,
             linetype = first_state,
             group = first_state)) + 
  geom_line()
```
### Defining the Cohort from a Separate Table

```{sql}
#| connection: db
WITH first_terms AS (
  SELECT id_bioguide, min(term_start) AS first_term
  FROM legislators_terms 
  GROUP BY 1)
  
SELECT d.gender,
  coalesce(date_part('year',age(c.date,a.first_term)),0) AS period,
  count(distinct a.id_bioguide) AS cohort_retained
FROM first_terms a
JOIN legislators_terms b ON a.id_bioguide = b.id_bioguide 
LEFT JOIN year_ends c ON c.date BETWEEN b.term_start AND b.term_end 
INNER JOIN legislators d ON a.id_bioguide = d.id_bioguide
GROUP BY 1,2
ORDER BY 2,1
LIMIT 4;
```

```{r}
cohorts <-
  first_terms %>%
  inner_join(legislators_terms, by = "id_bioguide") %>%
  left_join(year_ends, join_by(between(y$date, x$term_start, x$term_end))) %>%
  inner_join(legislators, by = "id_bioguide") %>%
  mutate(period = coalesce(year(age(date, first_term)), 0)) %>%
  group_by(gender, period) %>%
  summarize(cohort_retained = n_distinct(id_bioguide),
            .groups = "drop")

cohorts %>%
  arrange(period, gender) %>%
  collect(n = 4) %>%
  kable()
```

```{sql}
#| connection: db
WITH first_terms AS (
  SELECT id_bioguide, min(term_start) AS first_term
  FROM legislators_terms 
  GROUP BY 1),
  
cohorts AS (
  SELECT d.gender,
    coalesce(date_part('year',age(c.date,a.first_term)),0) as period,
    count(distinct a.id_bioguide) as cohort_retained
  FROM first_terms a
  JOIN legislators_terms b on a.id_bioguide = b.id_bioguide 
  LEFT JOIN year_ends c on c.date between b.term_start and b.term_end 
  JOIN legislators d on a.id_bioguide = d.id_bioguide
  GROUP BY 1, 2)
  
SELECT gender, period,
  cohort_retained,
  first_value(cohort_retained) OVER w AS cohort_size,
  cohort_retained * 1.0 / 
  first_value(cohort_retained) OVER w AS pct_retained
FROM cohorts aa
WINDOW w AS (partition by gender order by period)
ORDER BY 2, 1
LIMIT 4;
```

```{r}
cohorts %>%
  group_by(gender) %>%
  window_order(period) %>%
  mutate(cohort_size = first(cohort_retained)) %>%
  ungroup() %>%
  mutate(pct_retained = 1.0 * cohort_retained / cohort_size) %>%
    arrange(period, gender) %>%
  collect(n = 4) %>%
  kable()
```

```{sql}
#| connection: db
WITH first_terms AS (
  SELECT id_bioguide, min(term_start) AS first_term
  FROM legislators_terms 
  GROUP BY 1),
  
cohorts AS (
  SELECT d.gender,
    coalesce(date_part('year',age(c.date, a.first_term)),0) as period,
    count(distinct a.id_bioguide) as cohort_retained
  FROM first_terms a
  JOIN legislators_terms b on a.id_bioguide = b.id_bioguide 
  LEFT JOIN year_ends c on c.date between b.term_start and b.term_end 
  JOIN legislators d on a.id_bioguide = d.id_bioguide
  WHERE first_term BETWEEN '1917-01-01' AND '1999-12-31'
  GROUP BY 1, 2)
  
SELECT gender, period,
  cohort_retained,
  first_value(cohort_retained) OVER w AS cohort_size,
  cohort_retained * 1.0 / 
  first_value(cohort_retained) OVER w AS pct_retained
FROM cohorts aa
WINDOW w AS (partition by gender order by period)
ORDER BY 2, 1
LIMIT 4;
```


```{r}
cohorts <-
  first_terms %>%
  filter(between(first_term, '1917-01-01', '1999-12-31')) %>%
  inner_join(legislators_terms, by = "id_bioguide") %>%
  left_join(year_ends, join_by(between(y$date, x$term_start, x$term_end))) %>%
  inner_join(legislators, by = "id_bioguide") %>%
  mutate(period = coalesce(year(age(date, first_term)), 0)) %>%
  group_by(gender, period) %>%
  summarize(cohort_retained = n_distinct(id_bioguide),
            .groups = "drop") 

cohorts %>%
  group_by(gender) %>%
  window_order(period) %>%
  mutate(cohort_size = first(cohort_retained)) %>%
  ungroup() %>%
  mutate(pct_retained = 1.0 * cohort_retained / cohort_size) %>%
  arrange(period, gender) %>%
  collect(n = 4) %>%
  kable()
```

### Dealing with Sparse Cohorts

### Defining Cohorts from Dates other than the First Date

## Related Cohort Analyses

```{r}
dbDisconnect(db, shutdown = TRUE)
```