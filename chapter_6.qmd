# Anomaly Detection

```{r}
#| message: false
library(DBI)
library(tidyverse)
library(dbplyr)
library(knitr)
```

```{r}
#| output: false
pg <- dbConnect(RPostgres::Postgres(), bigint = "integer")
dbExecute(pg, "SET search_path TO sql_book")
```

```{r}
earthquakes <- tbl(pg, "earthquakes")
```

```{r}
earthquakes %>%
  filter(!is.na(mag)) %>%
  group_by(mag) %>%
  summarize(earthquakes = n()) %>%
  mutate(pct_earthquakes = earthquakes/sum(earthquakes,
                                           na.rm = TRUE)) %>%
  arrange(desc(mag)) %>%
  collect(n = 5) %>%
  kable()
```

```{r}
earthquakes %>%
  filter(!is.na(mag)) %>%
  group_by(mag) %>%
  summarize(earthquakes = n()) %>%
  mutate(pct_earthquakes = earthquakes/sum(earthquakes, 
                                           na.rm = TRUE)) %>%
  arrange(mag) %>%
  collect(n = 5) %>%
  kable()
```

```{r}
norcal <-
  earthquakes %>%
  filter(!is.na(mag), place == 'Northern California') %>%
  group_by(place, mag) %>%
  summarize(count = n(), .groups = "drop") 

norcal %>% 
  arrange(place, desc(mag)) %>% 
  collect(n = 3) %>%
  kable()

norcal %>% 
  arrange(place, mag) %>% 
  collect(n = 3) %>%
  kable()
```

```{r}
earthquakes %>%
  filter(!is.na(mag), place == 'Northern California') %>%
  group_by(place) %>%
  window_order(mag) %>%
  mutate(percentile = percent_rank()) %>%
  group_by(place, mag, percentile) %>%
  summarize(count = n(), .groups = "drop") %>%
  arrange(place, desc(mag)) %>%
  collect(n = 6) %>%
  kable()
```
```{r}
earthquakes %>%
  filter(!is.na(mag), place == 'Central Alaska') %>%
  select(place, mag) %>%
  mutate(percentile = ntile(100, order_by = "mag")) %>%
  arrange(place, desc(mag)) %>%
  collect(n = 5) %>%
  kable()
```

```{r}
earthquakes %>%
  filter(!is.na(mag), place == 'Central Alaska') %>%
  select(place, mag) %>%
  group_by(place) %>%
  window_order(mag) %>%
  mutate(percentile = round(percent_rank() * 100, 0)) %>%
  arrange(place, desc(mag)) %>%
  show_query()
```
Interestingly enough, there is no SQL translation of `ntile()` offered by `dbplyr`, even though this is a function provided by `dplyr` and presumably inspired by the SQL function.
And there does not seem to be an easy workaround using `dplyr` verbs and functions for which there are SQL translations (such as `cut()` and `quantile()`).
But we can achieve the right result using an SQL snippet as we do below.

```{r}
cen_ak_quartiles <-
  earthquakes %>%
  filter(!is.na(mag), place == 'Central Alaska') %>%
  select(place, mag) %>%
  group_by(place) %>%
  mutate(ntile = ntile(4, order_by = "mag"))

cen_ak_quartiles %>%
  group_by(place, ntile) %>%
  summarize(maximum = max(mag, na.rm = TRUE),
            minimum = min(mag, na.rm = TRUE),
            .groups = "drop") %>%
  arrange(place, desc(ntile)) %>%
  kable()
```

```{r}
earthquakes %>%
  filter(!is.na(mag), place == 'Central Alaska') %>%
  select(place, mag) %>%
  group_by(place) %>%
  summarize(pct_25 = quantile(mag, probs = 0.25, na.rm = TRUE),
            pct_50 = quantile(mag, probs = 0.50, na.rm = TRUE),
            pct_75 = quantile(mag, probs = 0.75, na.rm = TRUE)) %>%
  kable()
```

```{r}
earthquakes %>%
  filter(!is.na(mag), place == 'Central Alaska') %>%
  summarize(pct_25_mag = quantile(mag, probs = 0.25, na.rm = TRUE),
            pct_25_depth = quantile(depth, probs = 0.25, na.rm = TRUE)) %>%
  kable()
```

```{r}
earthquakes %>%
  filter(!is.na(mag), 
         place %in% c('Central Alaska', 'Southern Alaska')) %>%
  group_by(place) %>%
  summarize(pct_25_mag = quantile(mag, probs = 0.25, na.rm = TRUE),
            pct_25_depth = quantile(depth, probs = 0.25, na.rm = TRUE)) %>%
  kable()
```

```{r}
earthquakes %>%
  summarize(sd_mag = sd(mag, na.rm = TRUE),
            stddev_samp_mag = stddev_samp(mag),
            stddev_pop_mag = stddev_pop(mag)) %>%
  mutate(diff_samp = sd_mag - stddev_samp_mag,
         diff_pop = sd_mag - stddev_pop_mag) %>%
  collect() %>%
  kable()
```

Below Cathy uses `INNER JOIN` with `ON 1 = 1`.

```{sql}
#| eval: false
SELECT * 
FROM earthquakes a
INNER JOIN b ON 1 = 1
```

Instead, I use `CROSS JOIN` (this is `cross_join` in `dplyr`).

```{sql}
#| eval: false
SELECT * 
FROM earthquakes a
CROSS JOIN b
```

The output in the book differs from one gets from running the code, 
so I add `!(mag %in% c(-9, -9.99))` to get closer to the book's output.

Note that in constructing `mag_stats`, I follow the book in using `avg(mag)` and `stddev_pop(mag)`.
In practice, I would probably lean more to using R-compatible `mean(mag, na.rm = TRUE)` and `sd(mag, na.rm = TRUE)`, respectively.
This makes little differ in practice---the only difference is that `sd` is translated into `stddev_samp` instead of `stddev_pop`, which is barely different in this case---but I believe it is helpful to be consistent where possible.
Often I find myself moving the data processing from PosrtgreSQL to R or vice versa and this is much easier if the `dbplyr` code is consistent with the `dplyr` equivalent.

```{r}
mag_stats <-
  earthquakes %>%
  filter(!is.na(mag)) %>%
  summarize(avg_mag = avg(mag),
            std_dev = stddev_pop(mag))

z_scores <-
  earthquakes %>%
  filter(!is.na(mag), !(mag %in% c(-9, -9.99))) %>%
  select(place, mag) %>%
  cross_join(mag_stats) %>%
  mutate(z_score = (mag - avg_mag) / std_dev) 

z_scores %>%
  arrange(desc(mag)) %>%
  collect(n = 3) %>%
  kable()

z_scores %>%
  arrange(mag) %>%
  collect(n = 3) %>%
  kable()
```

## Graphing to find anomalies visually

```{r}
earthquakes %>%
  filter(!is.na(mag)) %>%
  ggplot(aes(x = mag)) +
  geom_histogram(breaks = seq(-10, 10, 0.1))
```

```{r}
earthquakes %>%
  filter(!is.na(mag),
         between(mag, 7.2, 9.5)) %>%
  ggplot(aes(x = mag)) +
  geom_histogram(binwidth = 0.1)
```

```{r}
earthquakes %>%
  filter(!is.na(mag),
         between(mag, 7.2, 9.5)) %>%
  ggplot(aes(x = mag)) +
  geom_bar() +
  scale_x_binned(breaks = seq(7.2, 9.5, 0.1))
```

```{r}
earthquakes %>%
  filter(!is.na(mag), !is.na(depth)) %>%
  distinct(mag, depth) %>%
  ggplot(aes(x = mag, y = depth)) +
  geom_point(size = 0.1, colour = "blue")
```

```{r}
earthquakes %>%
  filter(!is.na(mag), !is.na(depth)) %>%
  filter(between(mag, 4, 7), depth <= 50) %>%
  ggplot(aes(x = mag, y = depth)) +
  geom_count(color = "blue")
```

```{r}
japan_quakes <-
  earthquakes %>%
  filter(!is.na(mag), !is.na(depth)) %>%
  filter(place %~% "Japan") 

japan_quakes %>%
  ggplot(aes(y = mag)) +
  geom_boxplot(width = 0.5)
```

```{r}
japan_quakes %>%
  summarize(p25 = quantile(mag, probs = 0.25, na.rm = TRUE),
            p50 = quantile(mag, probs = 0.50, na.rm = TRUE),
            p75 = quantile(mag, probs = 0.75, na.rm = TRUE)) %>%
  mutate(iqr = (p75 - p25) * 1.5,
         lower_whisker = p25 - (p75 - p25) * 1.5,
         upper_whisker = p75 + (p75 - p25) * 1.5) %>%
  kable()
```

```{r}
japan_quakes %>%
  select(mag, time) %>%
  collect() %>%
  mutate(year = as.factor(year(time))) %>%
  ggplot(aes(y = mag, x = year, group = year)) +
  geom_boxplot()
```

## Forms of Anomalies

### Anomalous Values

```{r}
earthquakes %>%
  filter(mag >= 1.08) %>%
  group_by(mag) %>%
  summarize(count = n()) %>%
  arrange(mag) %>%
  collect(n = 5) %>%
  kable()
```

```{r}
earthquakes %>%
  filter(depth > 600) %>%
  group_by(net) %>%
  summarize(count = n()) %>%
  arrange(net) %>%
  collect(n = 5) %>%
  kable()
```
```{r}
earthquakes %>%
  filter(depth > 600) %>%
  group_by(place) %>%
  summarize(count = n()) %>%
  arrange(place) %>%
  collect(n = 5) %>%
  kable()
```

```{r}
earthquakes %>%
  filter(depth > 600) %>%
  mutate(place_name = case_when(place %~% ' of ' ~ split_part(place, ' of ', 2L),
                                TRUE ~ place)) %>%
  group_by(place_name) %>%
  summarize(count = n()) %>%
  arrange(desc(count)) %>%
  collect(n = 3) %>%
  kable()
```

```{r}
earthquakes %>%
  summarize(distinct_types = n_distinct(type),
            distinct_lower = n_distinct(lower(type))) %>%
  kable()
```

### Anomalous Counts or Frequencies